var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

/* globals __DEV__ */

import keyframesAndDuration from './keyframe';
import { valid } from './plain-shape-object';

/**
 * A sequence of static shapes.
 *
 * @typedef {Object} Shape
 *
 * @property {Keyframe[]} keyframes
 */

/**
 * An object containing PlainShapeObjects and shape options.
 *
 * @typedef {Object} SortedShapeProps
 *
 * @property {PlainShapeObject[]} plainShapeObjects
 * @property {Object} options
 * @property {(string|number)} options.name
 */

/**
 * Creates a Shape from one or more PlainShapeObject.
 * Optionally can take an options object as the last argument.
 *
 * @param {(PlainShapeObject|Object)[]} props
 *
 * @returns {Shape}
 *
 * @example
 * shape(circle, square)
 */
var shape = function shape() {
  for (var _len = arguments.length, props = Array(_len), _key = 0; _key < _len; _key++) {
    props[_key] = arguments[_key];
  }

  var _sort = sort(props),
      plainShapeObjects = _sort.plainShapeObjects,
      name = _sort.options.name;

  var _keyframesAndDuration = keyframesAndDuration(plainShapeObjects),
      duration = _keyframesAndDuration.duration,
      keyframes = _keyframesAndDuration.keyframes;

  var s = { duration: duration, keyframes: keyframes };

  if (typeof name !== 'undefined') {
    s.name = name;
  }

  return s;
};

/**
 * Sorts an array of props into a PlainShapeObject array and options.
 *
 * @param {(PlainShapeObject|Object)[]} props
 *
 * @returns {SortedShapeProps}
 *
 * @example
 * sort(props)
 */
var sort = function sort(props) {
  var plainShapeObjects = props.filter(function (prop) {
    if (process.env.NODE_ENV !== 'production' && (typeof prop === 'undefined' ? 'undefined' : _typeof(prop)) !== 'object') {
      throw new TypeError('The shape function must only be passed objects');
    }

    return prop.type;
  });

  var options = props.length > 1 && typeof props[props.length - 1].type === 'undefined' ? props[props.length - 1] : {};

  var sortedProps = { plainShapeObjects: plainShapeObjects, options: options };

  if (validProps(sortedProps)) {
    return sortedProps;
  }
};

/**
 * Validates a PlainShapeObject array and shape options.
 *
 * @param {SortedShapeProps}
 *
 * @throws {TypeError} Throws if not valid
 *
 * @returns {true}
 *
 * @example
 * validProps({ plainShapeObjects, options })
 */
var validProps = function validProps(_ref) {
  var plainShapeObjects = _ref.plainShapeObjects,
      name = _ref.options.name;

  if (process.env.NODE_ENV !== 'production' && plainShapeObjects.length === 0) {
    throw new TypeError('The shape function must be passed at least one Plain Shape Object');
  }

  if (process.env.NODE_ENV !== 'production' && valid.apply(undefined, _toConsumableArray(plainShapeObjects))) {
    if (typeof name !== 'undefined' && typeof name !== 'string' && typeof name !== 'number') {
      throw new TypeError('The name option passed to the shape function must be of type string or number');
    }
  }

  return true;
};

export default shape;