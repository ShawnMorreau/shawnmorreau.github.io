'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.transformPoints = exports.pointsToFrameShape = exports.flattenPoints = undefined;

var _points = require('points');

var transformFunctions = _interopRequireWildcard(_points);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _toArray(arr) { return Array.isArray(arr) ? arr : Array.from(arr); }

/**
 * A WeakMap where the key is a FrameShape and the value is
 * the index of the associated points within an array of Points.
 *
 * @typedef {weakmap} PointsMap
 */

/**
 * Applies a transform to a FrameShape.
 *
 * @param {FrameShape} frameShape
 * @param {(string|number)[]} transform
 *
 * @return {FrameShape}
 *
 * @example
 * transform(frameShape, [ 'rotate', 45 ])
 */
var apply = function apply(frameShape, _ref) {
  var _ref2 = _toArray(_ref),
      name = _ref2[0],
      args = _ref2.slice(1);

  var _flattenPoints = flattenPoints(frameShape),
      points = _flattenPoints.points,
      pointsMap = _flattenPoints.pointsMap;

  var transformedPoints = transformFunctions[name].apply(transformFunctions, [points].concat(_toConsumableArray(args)));

  return pointsToFrameShape({
    frameShape: frameShape,
    points: transformedPoints,
    pointsMap: pointsMap
  });
};

/**
 * Creates an array of Points from a FrameShape.
 *
 * @param {FrameShape} frameShape
 * @param {Points[]} [points=[]]
 * @param {PointsMap} [pointsMap=new WeakMap()]
 *
 * @return {Object}
 *
 * @example
 * flattenPoints(frameShape)
 */
var flattenPoints = function flattenPoints(frameShape) {
  var points = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  var pointsMap = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new WeakMap();

  var childFrameShapes = frameShape.childFrameShapes;

  if (childFrameShapes) {
    for (var i = 0, l = childFrameShapes.length; i < l; i++) {
      flattenPoints(childFrameShapes[i], points, pointsMap);
    }
  } else {
    pointsMap.set(frameShape, points.length);
    points.push(frameShape.points);
  }

  return { points: points, pointsMap: pointsMap };
};

/**
 * Applies an array of Points to a FrameShape using a PointsMap
 *
 * @param {Object} opts
 * @param {FrameShape} opts.frameShape
 * @param {Points[]} opts.points
 * @param {PointsMap} pointsMap
 *
 */
var pointsToFrameShape = function pointsToFrameShape(_ref3) {
  var frameShape = _ref3.frameShape,
      points = _ref3.points,
      pointsMap = _ref3.pointsMap;

  var childFrameShapes = frameShape.childFrameShapes;

  if (frameShape.points) {
    frameShape.points = points[pointsMap.get(frameShape)];
  }

  if (childFrameShapes) {
    for (var i = 0, l = childFrameShapes.length; i < l; i++) {
      pointsToFrameShape({
        frameShape: childFrameShapes[i],
        points: points,
        pointsMap: pointsMap
      });
    }
  }

  return frameShape;
};

/**
 * Applies an array of transforms to a FrameShape.
 *
 * @param {FrameShape} frameShape
 * @param {(string|number)[][]} transforms
 *
 * @return {FrameShape}
 *
 * @example
 * transform(frameShape, [[ 'rotate', 45 ]])
 */
var transform = function transform(frameShape, transforms) {
  for (var i = 0, l = transforms.length; i < l; i++) {
    frameShape = apply(frameShape, transforms[i]);
  }

  return frameShape;
};

/**
 * Applies an array of transforms to Points.
 *
 * @param {Points} points
 * @param {(string|number)[][]} transforms
 *
 * @return {Points}
 *
 * @example
 * transform(points, [[ 'rotate', 45 ]])
 */
var transformPoints = function transformPoints(points, transforms) {
  for (var i = 0, l = transforms.length; i < l; i++) {
    var _transforms$i = _toArray(transforms[i]),
        name = _transforms$i[0],
        args = _transforms$i.slice(1);

    points = transformFunctions[name].apply(transformFunctions, [points].concat(_toConsumableArray(args)));
  }

  return points;
};

exports.flattenPoints = flattenPoints;
exports.pointsToFrameShape = pointsToFrameShape;
exports.transformPoints = transformPoints;
exports.default = transform;