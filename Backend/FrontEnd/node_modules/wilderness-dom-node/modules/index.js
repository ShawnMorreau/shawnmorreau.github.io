var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

/* globals __DEV__ */

import { toPath, toPoints } from 'svg-points';

/**
 * A DOM node.
 *
 * @typedef {Object} Node
 */

/**
 * The data from a Node that is useful in FrameShape and PlainShapeObject creation.
 *
 * @typedef {Object} NodeData
 *
 * @property {Object} attributes - All HTML attributes of the Node (excluding blacklist).
 * @property {Object[]} childNodes
 * @property {string} type - The nodeName of the Node.
 */

/**
 * Attributes to ignore.
 */
var attributeBlacklist = ['data-jsx-ext', 'data-reactid'];

/**
 * Wilderness' accepted node types core props.
 */
var nodeCoreProps = [{
  type: 'circle',
  coreProps: ['cx', 'cy', 'r']
}, {
  type: 'ellipse',
  coreProps: ['cx', 'cy', 'rx', 'ry']
}, {
  type: 'g',
  coreProps: []
}, {
  type: 'line',
  coreProps: ['x1', 'x2', 'y1', 'y2']
}, {
  type: 'path',
  coreProps: ['d']
}, {
  type: 'polygon',
  coreProps: ['points']
}, {
  type: 'polyline',
  coreProps: ['points']
}, {
  type: 'rect',
  coreProps: ['height', 'rx', 'ry', 'width', 'x', 'y']
}];

/**
 * Generates Wilderness' accepted node types from core props object.
 *
 * @returns {string[]}
 *
 * @example
 * getNodeTypes()
 */
var getNodeTypes = function getNodeTypes() {
  var types = [];

  for (var i = 0, l = nodeCoreProps.length; i < l; i++) {
    types.push(nodeCoreProps[i].type);
  }

  return types;
};

/**
 * Wilderness' accepted node types.
 */
var nodeTypes = getNodeTypes();

/**
 * Core props for the defined node type.
 *
 * @param {string} type
 *
 * @returns {Object}
 *
 * @example
 * coreProps('rect')
 */
var coreProps = function coreProps(type) {
  for (var i = 0, l = nodeCoreProps.length; i < l; i++) {
    if (nodeCoreProps[i].type === type) {
      return nodeCoreProps[i].coreProps;
    }
  }

  return [];
};

/**
 * Creates a FrameShape from a Node.
 *
 * @param {Node} node
 *
 * @returns {FrameShape}
 *
 * @example
 * frameShapeFromNode(node)
 */
var frameShape = function frameShape(el) {
  if (validNode(el)) {
    var data = nodeData(el);
    var attributes = data.attributes;
    var type = data.type;

    if (type === 'g') {
      var childNodes = data.childNodes;
      var childFrameShapes = [];

      for (var i = 0, l = childNodes.length; i < l; i++) {
        var n = childNodes[i];

        if (validNodeType(childNodes[i].nodeName)) {
          childFrameShapes.push(frameShape(n));
        }
      }

      return { attributes: attributes, childFrameShapes: childFrameShapes };
    }

    return {
      attributes: removeCoreProps(type, attributes),
      points: toPoints(plainShapeObjectFromAttrs(type, attributes))
    };
  }
};

/**
 * Creates a group Node from a FrameShape array.
 *
 * @param {FrameShape[]} childFrameShapes
 *
 * @returns {Node}
 *
 * @example
 * groupNode(childFrameShapes)
 */
var groupNode = function groupNode(childFrameShapes) {
  var nodes = [];

  for (var i = 0, l = childFrameShapes.length; i < l; i++) {
    nodes.push(node(childFrameShapes[i]));
  }

  var group = document.createElementNS('http://www.w3.org/2000/svg', 'g');

  for (var _i2 = 0, _l2 = nodes.length; _i2 < _l2; _i2++) {
    group.appendChild(nodes[_i2]);
  }

  return group;
};

/**
 * Creates a Node from a FrameShape.
 *
 * @param {FrameShape} frameShape
 *
 * @returns {Node}
 *
 * @example
 * node(frameShape)
 */
var node = function node(frameShp) {
  if (validFrameShape(frameShp)) {
    var attributes = frameShp.attributes;

    var el = frameShp.childFrameShapes ? groupNode(frameShp.childFrameShapes) : pathNode(frameShp.points);

    for (var attr in attributes) {
      el.setAttribute(attr, attributes[attr]);
    }

    return el;
  }
};

/**
 * Creates NodeData given a Node.
 *
 * @param {Node} el
 *
 * @returns {NodeData}
 *
 * @example
 * nodeData(el)
 */
var nodeData = function nodeData(el) {
  var attributes = {};

  if (el.hasAttributes()) {
    var attrs = [].concat(_toConsumableArray(el.attributes));

    for (var i = 0, l = attrs.length; i < l; i++) {
      var attr = attrs[i];
      var name = attr.name;

      if (attributeBlacklist.indexOf(name) === -1) {
        attributes[name] = attr.value;
      }
    }
  }

  return { attributes: attributes, childNodes: [].concat(_toConsumableArray(el.childNodes)), type: el.nodeName };
};

/**
 * Creates a path Node from Points.
 *
 * @param {Points} points
 *
 * @returns {Node}
 *
 * @example
 * pathNode(points)
 */
var pathNode = function pathNode(points) {
  var path = document.createElementNS('http://www.w3.org/2000/svg', 'path');

  path.setAttribute('d', toPath(points));

  return path;
};

/**
 * Creates a PlainShapeObject from a Node.
 *
 * @param {Node} el
 *
 * @returns {PlainShapeObject}
 *
 * @example
 * plainShapeObject(el)
 */
var plainShapeObject = function plainShapeObject(el) {
  if (validNode(el)) {
    var data = nodeData(el);
    var attributes = data.attributes;
    var type = data.type;

    if (type === 'g') {
      var childNodes = data.childNodes;
      var shapes = [];

      for (var i = 0, l = childNodes.length; i < l; i++) {
        var n = childNodes[i];

        if (validNodeType(n.nodeName)) {
          shapes.push(plainShapeObject(n));
        }
      }

      return _extends({}, attributes, { type: type, shapes: shapes });
    }

    return _extends({}, attributes, plainShapeObjectFromAttrs(type, attributes));
  }
};

/**
 * Creates a PlainShapeObject from type and an attribute object.
 *
 * @param {string} type
 * @param {Object} attributes
 *
 * @returns {PlainShapeObject}
 *
 * @example
 * plainShapeObjectFromAttrs('rect', attributes)
 */
var plainShapeObjectFromAttrs = function plainShapeObjectFromAttrs(type, attributes) {
  var props = coreProps(type);
  var result = { type: type };

  for (var k in attributes) {
    if (props.indexOf(k) !== -1) {
      var v = attributes[k];
      var n = Number(v);
      result[k] = Number.isNaN(n) ? v : n;
    }
  }

  return result;
};

/**
 * Removes type's core props from attributes object.
 *
 * @param {string} type
 * @param {Object} attributes
 *
 * @returns {Object}
 *
 * @example
 * removeCoreProps('rect', attributes)
 */
var removeCoreProps = function removeCoreProps(type, attributes) {
  var props = coreProps(type);
  var result = {};

  for (var k in attributes) {
    if (props.indexOf(k) === -1) {
      result[k] = attributes[k];
    }
  }

  return result;
};

/**
 * Updates a Node from a FrameShape.
 *
 * @param {Node} el
 * @param {FrameShape} frameShape
 *
 * @returns {Node}
 *
 * @example
 * updateNode(el, frameShape)
 */
var updateNode = function updateNode(el, frameShp) {
  var changes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];

  if (process.env.NODE_ENV !== 'production') {
    if (!validNode(el)) {
      throw new TypeError('The first argument of the updateNode function must be a valid DOM node');
    }

    if (!validFrameShape(frameShp)) {
      throw new TypeError('The second argument of the updateNode function must be a valid frameShape');
    }
  }

  var shouldApplyChanges = changes.length === 0;
  var currentAttributes = el.attributes;
  var nextAttributes = frameShp.attributes;
  var childFrameShapes = frameShp.childFrameShapes;
  var changesKey = changes.push({ el: el, remove: [], update: {} }) - 1;

  for (var k in currentAttributes) {
    if (typeof nextAttributes[k] === 'undefined') {
      changes[changesKey].remove.push(k);
    }
  }

  for (var _k in nextAttributes) {
    var c = currentAttributes[_k];
    var n = nextAttributes[_k];

    if (typeof c === 'undefined' || c !== n) {
      changes[changesKey].update[_k] = n;
    }
  }

  if (!childFrameShapes) {
    var nextPath = toPath(frameShp.points);

    if (nextPath !== el.getAttribute('d')) {
      changes[changesKey].update.d = nextPath;
    }
  } else {
    var allChildNodes = [].concat(_toConsumableArray(el.childNodes));
    var childNodes = [];

    for (var i = 0, l = allChildNodes.length; i < l; i++) {
      var _n = allChildNodes[i];

      if (validNodeType(_n.nodeName)) {
        childNodes.push(_n);
      }
    }

    for (var _i3 = 0, _l3 = childFrameShapes.length; _i3 < _l3; _i3++) {
      updateNode(childNodes[_i3], childFrameShapes[_i3], changes);
    }
  }

  if (shouldApplyChanges) {
    for (var _i4 = 0, _l4 = changes.length; _i4 < _l4; _i4++) {
      var change = changes[_i4];
      var _el = change.el;
      var remove = change.remove;
      var update = change.update;

      for (var _i = 0, _l = remove.length; _i < _l; _i++) {
        _el.removeAttribute(remove[_i]);
      }

      for (var _k2 in update) {
        _el.setAttribute(_k2, update[_k2]);
      }
    }
  }

  return el;
};

/**
 * Is a FrameShape valid?
 *
 * @param {FrameShape} frameShp
 *
 * @throws {TypeError} Throws if not valid
 *
 * @returns {true}
 *
 * @example
 * validFrameShape(frameShape)
 */
var validFrameShape = function validFrameShape(frameShp) {
  if (process.env.NODE_ENV !== 'production') {
    if ((typeof frameShp === 'undefined' ? 'undefined' : _typeof(frameShp)) !== 'object' || Array.isArray(frameShp)) {
      throw new TypeError('frameShape must be of type object');
    }

    var attributes = frameShp.attributes;
    var childFrameShapes = frameShp.childFrameShapes;
    var points = frameShp.points;

    if (typeof attributes === 'undefined') {
      throw new TypeError('frameShape must include an attributes property');
    }

    if ((typeof attributes === 'undefined' ? 'undefined' : _typeof(attributes)) !== 'object' || Array.isArray(attributes)) {
      throw new TypeError('frameShape attributes property must be of type object');
    }

    if (typeof childFrameShapes === 'undefined' && typeof points === 'undefined') {
      throw new TypeError('frameShape must have either a points or childFrameShapes property');
    }

    if (points && !Array.isArray(points)) {
      throw new TypeError('frameShape points property must be of type array');
    }

    if (childFrameShapes) {
      if (!Array.isArray(childFrameShapes)) {
        throw new TypeError('frameShape childFrameShapes property must be of type array');
      }

      for (var i = 0, l = childFrameShapes.length; i < l; i++) {
        var childFrameShape = childFrameShapes[i];

        if ((typeof childFrameShape === 'undefined' ? 'undefined' : _typeof(childFrameShape)) !== 'object' || _typeof(childFrameShape.attributes) !== 'object') {
          throw new TypeError('frameShape childFrameShapes property must be array of frameShapes');
        }
      }
    }
  }

  return true;
};

/**
 * Is a Node valid?
 *
 * @param {Node} el
 *
 * @throws {TypeError} Throws if not valid
 *
 * @returns {true}
 *
 * @example
 * validNode(el)
 */
var validNode = function validNode(el) {
  if (process.env.NODE_ENV !== 'production') {
    if ((typeof el === 'undefined' ? 'undefined' : _typeof(el)) !== 'object' || !el.nodeName) {
      throw new TypeError('el must be a DOM node');
    }

    if (!validNodeType(el.nodeName)) {
      throw new TypeError('el must be an SVG basic shape or group element');
    }
  }

  return true;
};

/**
 * Is a node name one of the accepted node types?
 *
 * @param {string} nodeName
 *
 * @returns {boolean}
 *
 * @example
 * validNodeType(nodeName)
 */
var validNodeType = function validNodeType(nodeName) {
  return nodeTypes.indexOf(nodeName) !== -1;
};

export { frameShape, node, plainShapeObject, updateNode };