var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/* globals __DEV__ */

import { frame } from 'wilderness-core';
import { node } from 'wilderness-dom-node';
import { tick } from './timeline';

/**
 * An object holding both Shapes and Timelines.
 *
 * @typedef {Object} ShapesAndTimelines
 *
 * @property {Shape[]} shapes
 * @property {Timeline[]} timelines
 */

/**
 * Renders Shapes or Timelines to a container Node.
 *
 * @param {Node} container
 * @param {...(Shape|Timeline)} shapesAndTimelines
 *
 * @example
 * render(svg, shape, timeline)
 */
var render = function render(container) {
  for (var _len = arguments.length, shapesAndTimelines = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    shapesAndTimelines[_key - 1] = arguments[_key];
  }

  if (process.env.NODE_ENV !== 'production') {
    if ((typeof container === 'undefined' ? 'undefined' : _typeof(container)) !== 'object' || !container.nodeName) {
      throw new TypeError('The render function must be a DOM node as first argument');
    }
  }

  var shapesToRender = [];
  var result = split(shapesAndTimelines);
  var shapes = result.shapes;
  var timelines = result.timelines;

  for (var i = 0, l = shapes.length; i < l; i++) {
    var shape = shapes[i];
    shape.node = node(shape.keyframes[0].frameShape);
    shapesToRender.push(shape);
    shape.rendered = true;
  }

  for (var _i2 = 0, _l2 = timelines.length; _i2 < _l2; _i2++) {
    var timeline = timelines[_i2];
    var timelineShapes = timeline.timelineShapes;
    var frameShapes = frame(timeline);

    for (var _i = 0, _l = timelineShapes.length; _i < _l; _i++) {
      var _shape = timelineShapes[_i].shape;
      _shape.node = node(frameShapes[_i]);
      shapesToRender.push(_shape);
    }

    timeline.state.rendered = true;
  }

  for (var _i3 = 0, _l3 = shapesToRender.length; _i3 < _l3; _i3++) {
    var _shape2 = shapesToRender[_i3];

    if (_shape2.replace) {
      _shape2.replace.parentNode.replaceChild(_shape2.node, _shape2.replace);
      delete _shape2.replace;
    } else {
      container.appendChild(_shape2.node);
    }
  }

  tick();
};

/**
 * Splits a Shape and Timeline array into ShapesAndTimelines.
 *
 * @param {(Shape|Timeline)[]} shapesAndTimelines
 *
 * @returns {ShapesAndTimelines}
 *
 * @example
 * split([ shape, timeline ])
 */
var split = function split(shapesAndTimelines) {
  var result = { shapes: [], timelines: [] };

  for (var i = 0, l = shapesAndTimelines.length; i < l; i++) {
    var x = shapesAndTimelines[i];

    if ((typeof x === 'undefined' ? 'undefined' : _typeof(x)) === 'object' && x.keyframes) {
      if (process.env.NODE_ENV !== 'production') {
        if (x.timeline) {
          throw new Error('You cannot render a shape that has been placed on a timeline, instead render the timeline');
        }

        if (x.rendered) {
          throw new Error('You cannot render the same shape twice');
        }
      }

      result.shapes.push(x);
    } else if ((typeof x === 'undefined' ? 'undefined' : _typeof(x)) === 'object' && x.middleware && x.playbackOptions && x.state && x.timelineShapes) {
      if (process.env.NODE_ENV !== 'production' && x.state.rendered) {
        throw new Error('You cannot render the same timeline twice');
      }

      result.timelines.push(x);
    } else if (process.env.NODE_ENV !== 'production') {
      throw new Error('The render function only takes shapes and timelines from the second argument onwards');
    }
  }

  return result;
};

export default render;